<!doctype html>



  


<html class="theme-next muse use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="一只肥羊的思考">
<meta property="og:url" content="http://fatsheep9146.github.io/index.html">
<meta property="og:site_name" content="一只肥羊的思考">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一只肥羊的思考">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fatsheep9146.github.io/"/>





  <title> 一只肥羊的思考 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一只肥羊的思考</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://fatsheep9146.github.io/2018/08/26/kubernetes-volume-管理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ziqi Zhao (fatsheep9146)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一只肥羊的思考">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一只肥羊的思考" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/26/kubernetes-volume-管理/" itemprop="url">
                  kubernetes volume 管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-26T21:29:01+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是-Volume-特性"><a href="#什么是-Volume-特性" class="headerlink" title="什么是 Volume 特性"></a>什么是 Volume 特性</h1><p>在 kubernetes 中，数据存储是一个非常关键的问题。用户的某些类型的服务经常会有对数据存储方面的一些需求，比如：</p>
<ul>
<li>数据需要在容器重启之后，甚至 pod 被删除后，仍旧被保留</li>
<li>有些数据需要在同一个 pod 之间进行共享</li>
</ul>
<p>此时就需要用到 kubernetes 的 volume 特性[1]了。</p>
<p>而 kubernetes 中的 volume 特性使用起来也是非常简单的，我们只需要在 pod template spec 中指定我们希望使用的 volume，以及这个 volume 希望被这个 pod 中的每一个 container 以什么样子的方式来使用就好了。</p>
<p>举个栗子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: test-volume</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: test-container1</div><div class="line">      image: busybox</div><div class="line">      volumeMounts:</div><div class="line">        - name: config-vol</div><div class="line">          mountPath: /etc/config</div><div class="line">    - name: test-container2</div><div class="line">      image: busybox</div><div class="line">      volumeMounts:</div><div class="line">        - name: config-vol</div><div class="line">          mountPath: /mnt/config</div><div class="line">        - name: data</div><div class="line">          mountPath: /data</div><div class="line">  volumes:</div><div class="line">    - name: config-vol</div><div class="line">      configMap:</div><div class="line">        name: log-config</div><div class="line">    - name: data</div><div class="line">      persistentVolumeClaim:</div><div class="line">        claimName: test-pvc</div></pre></td></tr></table></figure>
<p>上面的这个 pod 其实就使用了两个 volume，分别叫做</p>
<ul>
<li>config-vol</li>
<li>data</li>
</ul>
<p>而这两个 volume 分别是用不同的方式提供的</p>
<ul>
<li>config-vol 的数据是由一个叫做 log-config 的 configmap 来提供的</li>
<li>data 的数据则是由一个叫做 test-pvc 的 persistentVolumeClaim 对象来提供的</li>
</ul>
<p>而这个 pod 中的两个 container 在使用两个 volume 时的使用姿势也是有差别的</p>
<ul>
<li>test-container1 仅仅使用了 config-vol 这个 volume，并且挂载到了自己的 /etc/config 路径下面</li>
<li>test-container2 也使用了 config-vol 这个 volume，但是它挂载到了自己的 /mnt/config 路径下面；另外它也是用了 data 这个 volume，并且挂载到了 /data 目录下面。</li>
</ul>
<p>所以总结来看 kubernetes 中的 volume 是为了满足 pod 的各种数据存储需求所提供的特性。</p>
<ul>
<li>每一个 pod 使用的 volume 背后可能由不同的存储方式来提供的，比如 configmap，emptyDir，persistentVolumeClaim 等等</li>
<li>pod 中的每一个 container 都可以用自己的方式来使用这个 pod 中的任意一个 volume</li>
</ul>
<p>而至于这个 volume 中的数据的生命周期，则跟 volume 背后是由哪种存储方式提供强相关。</p>
<ul>
<li>但是可以保证一点的是，无论采用哪种存储方式提供，volume 机制都能够保证在 container 发生重启的时候数据不会丢失。</li>
</ul>
<h1 id="常见的-Volume-类型"><a href="#常见的-Volume-类型" class="headerlink" title="常见的 Volume 类型"></a>常见的 Volume 类型</h1><p>在上一节中我们有一个非常重要的结论：</p>
<ul>
<li>volume 中的数据的生命周期，则跟 volume 背后是由哪种存储方式提供强相关。</li>
</ul>
<p>所以根据我们的业务场景的中对数据的持久性，读写性能等等的不同需求，我们也需要选择不同的 Volume 类型来满足</p>
<p>比如我们平时比较常见的 Volume 类型包括</p>
<ul>
<li>configmap：常用于为业务提供启动配置文件，这种小文件读取的需求；特点是只读，并且生命周期独立于 pod，即 pod 消失 configmap 仍旧存在</li>
<li>emptyDir：常用于同一个 pod 中的多个 container 进行少量文件的数据共享；特点是可读写，但是读写性能有限（取决于 kubelet 业务数据盘背后采用什么存储），并且没有 quota 限制，生命周期和 pod 完全一致，pod 被销毁，emptyDir 也会被删除</li>
<li>hostPath: 常用于 pod 希望访问主机上的某一个路径的场景，特点是可读写，生命周期独立于 pod</li>
<li>cephfs/nfs/rbd: 常用于 pod 希望使用网络存储来对数据进行持久化的场景</li>
<li>persistentVolumeClaim[2]：最新的一种让 pod 申请 volume 存储的形式，pod 可以通过创建一个 persistentVolumeClaim 对象来指明自己对这块 volume 存储的需求，比如大小，存储类型（比如 nfs，ceph rbd），生命周期完全独立于 pod。</li>
</ul>
<h1 id="PersistentVolumeClaim-机制"><a href="#PersistentVolumeClaim-机制" class="headerlink" title="PersistentVolumeClaim 机制"></a>PersistentVolumeClaim 机制</h1><p>在上小节我们提到的 volume 的类型很丰富，包括 nfs，ceph rbd，cephfs，awsElasticBlockStore 等等，这些类型在 persistentVolumeClaim 概念出现之前是可以直接在 pod volume 字段中直接写明对这种 volume 的需求的，比如 cephfs，如果不采用 persistentVolumeClaim 机制的话，你需要在 volume 的字段中显式的写入跟这个 cephfs 的 volume 相关的配置，比如 monitors 的地址等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: cephfs</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - name: cephfs-rw</div><div class="line">    image: kubernetes/pause</div><div class="line">    volumeMounts:</div><div class="line">    - mountPath: &quot;/mnt/cephfs&quot;</div><div class="line">      name: cephfs</div><div class="line">  volumes:</div><div class="line">  - name: cephfs</div><div class="line">    cephfs:</div><div class="line">      monitors:</div><div class="line">      - 10.16.154.78:6789</div><div class="line">      - 10.16.154.82:6789</div><div class="line">      - 10.16.154.83:6789</div><div class="line">      # by default the path is /, but you can override and mount a specific path of the filesystem by using the path attribute</div><div class="line">      # path: /some/path/in/side/cephfs </div><div class="line">      user: admin</div><div class="line">      secretFile: &quot;/etc/ceph/admin.secret&quot;</div><div class="line">      readOnly: true</div></pre></td></tr></table></figure>
<p>但是引入 persistentVolumeClaim 机制后，这些跟存储类型相关的全局配置信息都可以被封装到一个叫做 storageClass[3] 的对象的描述中，比如针对上面的例子，我们可以创建一个叫做 cephfs 的 storageClass 类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apiVersion: storage.k8s.io/v1</div><div class="line">kind: StorageClass</div><div class="line">metadata:</div><div class="line">  name: cephfs</div><div class="line">parameters:</div><div class="line">  adminId: admin</div><div class="line">  adminSecretName: ceph-admin-secret</div><div class="line">  adminSecretNamespace: kube-system</div><div class="line">  monitors: 192.168.213.25:6789,192.168.213.27:6789,192.168.213.28:6789</div><div class="line">provisioner: ceph.com/cephfs</div><div class="line">reclaimPolicy: Delete</div></pre></td></tr></table></figure>
<p>此时，如果用户还是想要申请一块 cephfs 类型的 volume 来使用的话，它只需要创建一个 persistentVolumeClaim 对象即可，并且该对象中应该写明，希望的 storageClass 为 cephfs，并且还有一些其他的配置要求，比如大小，读写模式等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: PersistentVolumeClaim</div><div class="line">metadata:</div><div class="line">  name: cephfs-pvc</div><div class="line">spec:</div><div class="line">  accessModes:</div><div class="line">  - ReadWriteMany</div><div class="line">  resources:</div><div class="line">    requests:</div><div class="line">      storage: 1Ti</div><div class="line">  storageClassName: cephfs</div></pre></td></tr></table></figure>
<p>此时，这个 pod 的 volume 就可以修改一下改为使用这个 persistentVolumeClaim</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: cephfs</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - name: cephfs-rw</div><div class="line">    image: kubernetes/pause</div><div class="line">    volumeMounts:</div><div class="line">    - mountPath: &quot;/mnt/cephfs&quot;</div><div class="line">      name: cephfs</div><div class="line">  volumes:</div><div class="line">  - name: cephfs</div><div class="line">    persistentVolumeClaim:</div><div class="line">      claimName: cephfs-pvc</div></pre></td></tr></table></figure>
<p>可见采用 persistentVolumeClaim 的好处有很多，不仅让接口更加清晰，也让用户对存储资源的管理更加方便。</p>
<h1 id="persistentVolumeClaim-管理逻辑"><a href="#persistentVolumeClaim-管理逻辑" class="headerlink" title="persistentVolumeClaim 管理逻辑"></a>persistentVolumeClaim 管理逻辑</h1><p>persistentVolumeClaim 机制是现在比较常见的存储使用方式，对于它的理解将非常有助于我们解决对使用 pvc 的 pod 在启动，停止过程中遇到的各种问题。</p>
<p>那么当我们为一个 pod 创建了一个 pvc ，并且把这个 pod 和这个 pvc 绑定之后都发生了什么事情呢？都有哪些组件参与到了这个过程中呢？</p>
<p>我们在这一篇博文中仅粗略介绍一下这个 pvc 被申请，被初始化，再到被 pod 所使用的整个流程，并且每一个步骤我们还会通过单独的博文从代码的角度来分析具体的工作逻辑。并且我是针对我们公司使用的一个具体场景来进行介绍（ceph rbd with external provisioner）</p>
<p>整个 pvc 管理周期主要分为以下几个</p>
<ul>
<li>Provisioning</li>
<li>Binding</li>
<li>Using</li>
</ul>
<h2 id="Provisioning"><a href="#Provisioning" class="headerlink" title="Provisioning"></a>Provisioning</h2><p>当 PVC 被创建后，第一步就是 Provisioning，PersistentVolumeClaim 从字面上来看也可以看出来，它只是一个对存储资源的需求的声明，针对这个声明，kubernetes 需要创造一个相应的“实体”，才能满足这个声明的需求。那么在 kubernetes 中，这个实体就是 PersistentVolume 对象。</p>
<p>所以如果想要 PersistentVolumeClaim 声明的存储需求被满足，我们就必须有能够满足需求的 PersistentVolume 存在，那么这个 PersistentVolume 是如何被创建出来的呢？</p>
<p>PersistentVolume 有两种途径被创建</p>
<ul>
<li><p>static provisioning: 顾名思义，需要集群管理员，在 PersistentVolumeClaim 还没创建好的时候就要手动创建好一些 PersistentVolume</p>
</li>
<li><p>dynamic provisioning: 顾名思义，这种场景下，会有一个组件，去动态获取新创建的 PersistentVolumeClaim 信息，来直接动态创建和这个 pvc 需求相符的 PersistentVolume</p>
</li>
</ul>
<p>其中 dynamic provisioning 是一种更加灵活的方式，社区中已经针对不同的存储技术开发了不同的组件来完成这个 dynamic provisioning 的流程，详情可以参考 <a href="https://github.com/kubernetes-incubator/external-storage" target="_blank" rel="external">https://github.com/kubernetes-incubator/external-storage</a> </p>
<h2 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h2><p>在 PersistentVolumeClaim 被创建后，而且也有了被创建好的 PersistentVolume 之后，就要开启 Binding 的步骤。很显然就是要为 PersistentVolumeClaim 选取最为合适的 PersistentVolume。PersistentVolumeClaim 和 PersistentVolume 是一对一的关系，不允许有一对多的关系存在。</p>
<p>所以当一个 PersistentVolumeClaim 申请了 100G 的容量时，但是目前系统中仅仅存在 200G 的 PersistentVolume 时，k8s 也会把二者 bind 起来</p>
<p>当然如果 PersistentVolume 是 dynamic provision 的方式创建出来的话，那么这个 PersistentVolumeClaim 和 PersistentVolume 之间的对应关系就已经被建立好了，无需再进行选择。</p>
<p>这个部分的工作使用 kube-controller-manager 中的 PvController 组件来完成的。</p>
<p>另外在 bind 之后，kube-controller-manager 中还存在一个 AttachDetachController，这个 controller 的工作是当某个 pvc 所对应的 pod 被调度到某台机器上面之后，AttachDetachController 会在逻辑上先把这个 PersistentVolume 和这个机器 attach 到一起，保证那些不支持多个 pod 共享的 pv 类型不会被同时两个 pod 所使用。</p>
<h2 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h2><p>最后一步就是 using，也就是说，当某一个使用这个 pvc 的 pod 被调度到某一台机器上以后，每台机器上面的 kubelet 会最终完成对这个 PersistentVolume 的实体化初始化，并且最终 mount 到这个 pod 的容器的指定目录里面去。</p>
<p>当然这个过程还有很多细节，比如 kubelet 会首先等待 AttachDetachController 把这个 PV 和所在的机器 attach 完成之后再进行后续操作，另外 PV 对应的 volume 会被首先 mount 到一个全局路径下，然后再 remount 到每一个 pod 的某个路径下。这样做是因为有些 PV 是可以支持被多个 Pod 所同时使用的，等等。这一系列的动作都是有 kubelet 中的 volumeManager 来完成的。</p>
<p>在后面的博文中，我们会针对 volume 整个生命周期中涉及到的所有组件进行一一解析，为大家还原 kubernetes 对 volume 的管理逻辑。</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes" target="_blank" rel="external">https://kubernetes.io/docs/concepts/storage/volumes</a></li>
<li><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">https://kubernetes.io/docs/concepts/storage/persistent-volumes/</a></li>
<li><a href="https://kubernetes.io/docs/concepts/storage/storage-classes" target="_blank" rel="external">https://kubernetes.io/docs/concepts/storage/storage-classes</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://fatsheep9146.github.io/2018/08/19/Go-项目单元测试最佳实践/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ziqi Zhao (fatsheep9146)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一只肥羊的思考">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一只肥羊的思考" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/19/Go-项目单元测试最佳实践/" itemprop="url">
                  Go 项目单元测试最佳实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-19T13:26:05+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Go 语言项目中，单元测试是必不可少的，就像我们在这篇博文中介绍的那样，单元测试占所有测试代码的 70% 的比重才算合理，可见单元测试的重要性。</p>
<p>这篇博文中，主要记录了一些常见的 Go 语言单元测试的最佳实践，当然这是一个可能后续会不断丰富完善的文档。</p>
<h2 id="Table-Driven-Test"><a href="#Table-Driven-Test" class="headerlink" title="Table Driven Test"></a>Table Driven Test</h2><p>table driven test [1][2] 是很多 Go 语言开发者所推崇的测试代码编写方式，Go 语言标准库的测试也是通过这个结构来撰写的，比如 <a href="https://golang.org/src/time/time_test.go" target="_blank" rel="external">time</a> 库的测试。</p>
<p>整体来讲，table driven test 的基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var testcases = []struct &#123;</div><div class="line">	in  string</div><div class="line">	out string</div><div class="line">&#125;&#123;</div><div class="line">	&#123;&quot;in1&quot;, &quot;out1&quot;&#125;,</div><div class="line">	&#123;&quot;in2&quot;, &quot;out2&quot;&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">func TestAFunc(t *testing.T) &#123;</div><div class="line">	for _, tt := range testcases &#123;</div><div class="line">		s := A(tt.in)</div><div class="line">		if s != tt.out &#123;</div><div class="line">			t.Errorf(&quot;got %q, want %q&quot;, s, tt.out)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中可见我们通过匿名结构体构建了每一个测试用例的结构，一个输入 in 和一个我们期望的输出 out，然后在真实的测试函数中，通过 range 轮询每一个测试用例，并且调用测试函数，比较输出结果，如果输出结果不等于我们期望的结果，即报错。</p>
<p>这种测试框架最好的一点在于，结构清晰，并且添加新的测试 case 会非常方便，所以也是最为推荐的一种测试的编写方式。</p>
<h2 id="Test-Fixtures-Golden-Files"><a href="#Test-Fixtures-Golden-Files" class="headerlink" title="Test Fixtures, Golden Files"></a>Test Fixtures, Golden Files</h2><p>在某些场景下，我们的测试可能需要一些除了测试源码以外的额外的文件，比如我们在测试对 json 文件的解码功能时，就需要一些示例的 json 文件作为测试 case 的输入。</p>
<p>像这种场景，把这些测试过程中用到的辅助文件，通常就叫做 test fixtures[3][4][5]。而放置这些文件最佳的路径，就是测试代码所在路径的一个名字为 testdata 的子目录下面，原因有二</p>
<ul>
<li>测试代码运行时，他的 working dir 就是测试代码的当前路径</li>
<li>go 语言在编译时会忽略名字叫做 testdata 的子目录</li>
</ul>
<p>所以二者结合，我们应该把这些文件放在这样的路径下</p>
<p>而 Golden Files 又是什么呢？Golden Files 其实就是 test fixtures 中的一种，当测试用例的输出结果比较简单的时候，我们还可以把输出结果写在测试代码中 。但是当输出结果比较复杂时，直接写入代码已经不太合适了。所以此时，我们通常会把正确结果写入到文件里面，并且测试代码运行时，需要读取这个文件的内容进行比较。</p>
<p>一般 Golden File 的使用都会配合 Table Driven Test，每一个测试 case 的 Golden File 的名字一般就会以“这个 case 的名字+.golden” 来命名，这样在编写代码时也会比较简单。</p>
<p>标准库就包含这种使用方法的很多实例，比如对 gofmt 的测试 case：<a href="https://golang.org/src/cmd/gofmt/gofmt_test.go" target="_blank" rel="external">https://golang.org/src/cmd/gofmt/gofmt_test.go</a></p>
<h2 id="test-包"><a href="#test-包" class="headerlink" title="*_test 包"></a>*_test 包</h2><p>单元测试文件一般被放置在待测试文件的同级目录下，而且文件名称基本和待测试文件名称加上”_test.go” 的规则来进行命名。</p>
<p>那么单测代码应该放在那个 package 中呢？一般没有特殊的需求的话，单元测试应该仅仅关注待测试的 package 的 exported 方法的测试。因为这些 exported 方法是这个 package 对外进行交互的唯一接口，所以必须要保证它的一致性。</p>
<p>所以一般也会将测试代码放置到另一个 package 中，假设待测试的 package 名称叫做 fmt，那么它的单测代码一般所在的包名为 fmt_test。</p>
<p>但是如果你真的需要对一些逻辑比较复杂的非 exported 函数进行测试的话，测试代码一定必须要和待测试的 package 在同一个 package 中。所以此时的最佳实践一般是再构建一个文件，名称为 <package>_internal_test.go。此时这些测试代码的 package 是和这个package 位于同一个 package 中。</package></p>
<p>所以一个完整的测试代码目录结构应该如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-- gofmt</div><div class="line">   |-- gofmt.go (package gofmt)</div><div class="line">   |-- gofmt_internal_test.go (package gofmt)</div><div class="line">   |-- gofmt_test.go (package gofmt_test)</div></pre></td></tr></table></figure>
<h2 id="TBD"><a href="#TBD" class="headerlink" title="TBD"></a>TBD</h2><ul>
<li>Mock 技术</li>
<li>Http Server 测试</li>
<li>并发测试</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go" target="_blank" rel="external">https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go</a></li>
<li><a href="https://github.com/golang/go/wiki/TableDrivenTests" target="_blank" rel="external">https://github.com/golang/go/wiki/TableDrivenTests</a></li>
<li><a href="https://speakerdeck.com/mitchellh/advanced-testing-with-go?slide=22" target="_blank" rel="external">https://speakerdeck.com/mitchellh/advanced-testing-with-go?slide=22</a></li>
<li><a href="https://medium.com/soon-london/testing-with-golden-files-in-go-7fccc71c43d3" target="_blank" rel="external">https://medium.com/soon-london/testing-with-golden-files-in-go-7fccc71c43d3</a></li>
<li><a href="https://dave.cheney.net/2016/05/10/test-fixtures-in-go" target="_blank" rel="external">https://dave.cheney.net/2016/05/10/test-fixtures-in-go</a></li>
<li><a href="https://medium.com/@benbjohnson/structuring-tests-in-go-46ddee7a25c" target="_blank" rel="external">https://medium.com/@benbjohnson/structuring-tests-in-go-46ddee7a25c</a></li>
<li><a href="https://talks.golang.org/2014/testing.slide#15" target="_blank" rel="external">https://talks.golang.org/2014/testing.slide#15</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://fatsheep9146.github.io/2018/08/12/Go-语言项目测试最佳实践/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ziqi Zhao (fatsheep9146)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一只肥羊的思考">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一只肥羊的思考" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/12/Go-语言项目测试最佳实践/" itemprop="url">
                  Go 语言项目测试最佳实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T21:29:09+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自动化测试对于一个产品的快速迭代是非常关键的一环，这篇文章主要关注的就是有关自动化测试方面的一些最佳实践，已经在 Go 语言项目中有关测试代码上的一些具体的最佳实践。</p>
<h1 id="测试包含哪几种"><a href="#测试包含哪几种" class="headerlink" title="测试包含哪几种"></a>测试包含哪几种</h1><p>常见的测试类型主要包括</p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>E2E 测试</li>
</ul>
<p>几种，不同的测试具备不同的特质，也适用于不同的目的。</p>
<p>首先，「单元测试」根据定义指的是针对代码中的某个独立单元，（比如一个类，一个方法）的测试方法。可见这种测试的优势就在于</p>
<ul>
<li>编写简单</li>
<li>定位错误精准</li>
</ul>
<p>但是缺陷也显而易见</p>
<ul>
<li>测试范围有限</li>
</ul>
<p>再看「集成测试」，集成测试要比单元测试的范围更大一点，一般涉及到多个模块之间的配合测试，自然而然，他的编写难度也要比单元测试难一些。但是他可以很好的快速发现多个模块单独测试没有问题，但是一起协同工作出现问题的场景。</p>
<p>另外 kubernetes 社区对于集成测试的约束也很有意思，他认为集成测试还应该满足所有测试需要的服务都应该在一台机器上启动。</p>
<p>最后「E2E 测试」，E2E 测试则更多的是模拟用户的行为对整个产品进行整体测试，比如开发一款 app，E2E 测试可能会模拟一个用户，注册，登录，点击产品等等一系列行为。所以这种测试方法的优势在于</p>
<ul>
<li>快速确认产品是否存在 bug，并且 bug 是真实用户会感知的</li>
</ul>
<p>虽然能够确认有 bug ，但是由于 bug 可能是 E2E 测试中涉及到的多个组件中的任何一个，所以它的缺陷也很明显</p>
<ul>
<li>无法快速定位问题代码</li>
<li>编写难度也是最大的</li>
</ul>
<p>所以也正是基于上述不同测试的优缺点，<a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html" target="_blank" rel="external">Google</a> 也总结出针对这几种测试的比例的最佳实践。</p>
<blockquote>
<p>As a good first guess, Google often suggests a 70/20/10 split: 70% unit tests, 20% integration tests, and 10% end-to-end tests.</p>
</blockquote>
<p>也就是说一个稳定的项目，它的单元测试，集成测试，E2E 测试的数量应该以 7:2:1 的比例分布，形成一个金字塔的形状，塔底是大量的单元测试，塔顶是少量的 E2E 测试。</p>
<p>下面我们也将通过单独的博文分别介绍，单元测试，集成测试，E2E 测试各自的最佳实践。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://fatsheep9146.github.io/2018/08/12/kubelet-的-Pod-信息源/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ziqi Zhao (fatsheep9146)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一只肥羊的思考">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一只肥羊的思考" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/12/kubelet-的-Pod-信息源/" itemprop="url">
                  kubelet 的 Pod 信息源
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T21:25:12+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h1><p>在之前的博文中，我们总结过，kubelet 整体是工作在「生产者与消费者」的模型之下的。</p>
<p>而其中生产者生产的消息就是有关「pod 发生变化」的通知，那么 kubelet 都有哪些消息生产者呢？</p>
<p>在这一篇博文中，我们主要关注的就是 kubelet 中的信息生产者，以及他们都生产了哪些消息</p>
<h1 id="生产者介绍"><a href="#生产者介绍" class="headerlink" title="生产者介绍"></a>生产者介绍</h1><p>首先我们可以再回顾一下 kubelet 中一段比较重要的函数 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1839:20" target="_blank" rel="external">syncLoopIteration</a>，这个是 kubelet 中最重要的循环函数，这个函数的内容就是在不停的通过 watch 所有消息生产者带来的消息，从而最终启动对应的 worker 函数去处理。</p>
<p>而在这个函数中我们就可以看到所有的消息生产者了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,</div><div class="line">	syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;</div><div class="line">	select &#123;</div><div class="line">	case u, open := &lt;-configCh:</div><div class="line">	...</div><div class="line">	case e := &lt;-plegCh:</div><div class="line">	...</div><div class="line">	case &lt;-syncCh:</div><div class="line">	...</div><div class="line">	case update := &lt;-kl.livenessManager.Updates():</div><div class="line">	...</div><div class="line">	case &lt;-housekeepingCh:</div><div class="line">	...</div><div class="line">	return true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，一共有 5 在阻塞等待的 channel，其中 syncCh，housekeepCh，都是周期性触发的信号，属于被动的消息。而真正主动的消息生产者就是 </p>
<ul>
<li><p>configCh：这个 channel 是由 Dependencies 类型中 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L266" target="_blank" rel="external">PodConfig</a> 对象提供的 channel）；该对象主要用于管理来自 3 个不同的信息源所发送的 pod 信息，apiserver，file，http，这也是 kubelet 中最为重要的一个 pod 事件源。这个事件源主要关注的是 Pod 静态信息（PodSpec）的变化。</p>
</li>
<li><p>plegCh：这个 channel 是由 Kubelet 对象中 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1081" target="_blank" rel="external">pleg</a> 子模块提供的 channel，这个子模块关注的是 Pod 动态信息的变化，比如 Container 的状态变化（已启动，已停止）。</p>
</li>
<li>update：这个 channel 是有 Kubelet 对象中的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1002" target="_blank" rel="external">livenessManager</a> 子模块提供的 channel，这个子模块关注的是有关 Container 的 Liveness Probe 结果信息。</li>
</ul>
<p>下面我们分别对这 3 个事件源的具体实现进行介绍。</p>
<h2 id="PodConfig"><a href="#PodConfig" class="headerlink" title="PodConfig"></a>PodConfig</h2><p>在上一小节，我们简要介绍了，PodConfig 对象主要是监听来自 3 种不同来源的 pod 信息，进行汇总发送给 kubelet。而它所发送的消息格式是由 PodUpdate 这个类型来描述的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type PodUpdate struct &#123;</div><div class="line">	Pods   []*v1.Pod</div><div class="line">	Op     PodOperation</div><div class="line">	Source string</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kubelet 就是通过 watch PodConfig 对象传递给它的 PodUpdate 类型的 channel 来获取信息的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,</div><div class="line">	syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;</div><div class="line">	select &#123;</div><div class="line">	case u, open := &lt;-configCh:</div><div class="line">	...</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么 PodConfig 自身又是如何工作的呢？</p>
<p>PodConfig 为每一个信息源（file，http，apiserver），分别创建了两个资源</p>
<ul>
<li>一个 channel: 用于接受该信息源发送过来的 pod 信息</li>
<li>一个 本地缓存 map: 用于暂时缓存在这个机器上， 最近的来自这个源的所有 pod 的信息</li>
</ul>
<p>每一个信息源，都会向 PodConfig 为它提供的 channel 中发送他获取的有关这个来源的 pod 信息。但是这些信息很可能会有重复的现象，所以 PodConfig 在获取到这些信息的时候，还会最终调用一个 Merge 函数，该函数会基于这个源的 pod 信息缓存来判断到底有哪些对 pod 的更新是真的需要关注的，以及到底是怎样的更新行为，比如创建，删除，更新等等。</p>
<p>举个栗子，apiserver 这个信息源对象，它是一个以 cache.NewUndeltaStore 为缓存的 Reflector 类型的对象，下面是它的初始化函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// NewSourceApiserver creates a config source that watches and pulls from the apiserver.</div><div class="line">func NewSourceApiserver(c clientset.Interface, nodeName types.NodeName, updates chan&lt;- interface&#123;&#125;) &#123;</div><div class="line">	lw := cache.NewListWatchFromClient(c.CoreV1().RESTClient(), &quot;pods&quot;, metav1.NamespaceAll, fields.OneTermEqualSelector(api.PodHostField, string(nodeName)))</div><div class="line">	newSourceApiserverFromLW(lw, updates)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// newSourceApiserverFromLW holds creates a config source that watches and pulls from the apiserver.</div><div class="line">func newSourceApiserverFromLW(lw cache.ListerWatcher, updates chan&lt;- interface&#123;&#125;) &#123;</div><div class="line">	send := func(objs []interface&#123;&#125;) &#123;</div><div class="line">		var pods []*v1.Pod</div><div class="line">		for _, o := range objs &#123;</div><div class="line">			pods = append(pods, o.(*v1.Pod))</div><div class="line">		&#125;</div><div class="line">		updates &lt;- kubetypes.PodUpdate&#123;Pods: pods, Op: kubetypes.SET, Source: kubetypes.ApiserverSource&#125;</div><div class="line">	&#125;</div><div class="line">	r := cache.NewReflector(lw, &amp;v1.Pod&#123;&#125;, cache.NewUndeltaStore(send, cache.MetaNamespaceKeyFunc), 0)</div><div class="line">	go r.Run(wait.NeverStop)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不了解这个 cache.NewUndeltaStore 还有 Reflector 对象也没有关系，总之，这个 apiserver 的行为是这样的：无论是任何一个或者多个 pod 的创建，删除还是更新操作，都会导致这个对象把它当前得到所有和这个机器相关的 pod 信息都发送给 PodConfig 给他的 channel。自然这会导致大量的重复，所以 PodConfig 需要进行 Merge 过滤。</p>
<p>PodConfig 的 Merge 函数的具体细节如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (s *podStorage) Merge(source string, change interface&#123;&#125;) error &#123;</div><div class="line">	s.updateLock.Lock()</div><div class="line">	defer s.updateLock.Unlock()</div><div class="line">	...</div><div class="line">	adds, updates, deletes, removes, reconciles, restores := s.merge(source, change)</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见其中会调用一个 merge 函数，该函数作用就是针对不同的源发送过来的消息进行过滤筛选，筛选出哪些 pod 的新创建的，对应的就是返回值 adds；哪些是更新的，对应的就是返回 updates 等等。</p>
<p>而 merge 函数作为过滤器其中最重要的就是它如何判断当前信息的类型的子函数，就是 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/config/config.go#L441" target="_blank" rel="external">checkAndUpdatePod</a> 子函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// checkAndUpdatePod updates existing, and:</div><div class="line">//   * if ref makes a meaningful change, returns needUpdate=true</div><div class="line">//   * if ref makes a meaningful change, and this change is graceful deletion, returns needGracefulDelete=true</div><div class="line">//   * if ref makes no meaningful change, but changes the pod status, returns needReconcile=true</div><div class="line">//   * else return all false</div><div class="line">//   Now, needUpdate, needGracefulDelete and needReconcile should never be both true</div><div class="line">func checkAndUpdatePod(existing, ref *v1.Pod) (needUpdate, needReconcile, needGracefulDelete bool) &#123;</div><div class="line"></div><div class="line">	// 1. this is a reconcile</div><div class="line">	// TODO: it would be better to update the whole object and only preserve certain things</div><div class="line">	//       like the source annotation or the UID (to ensure safety)</div><div class="line">	if !podsDifferSemantically(existing, ref) &#123;</div><div class="line">		// this is not an update</div><div class="line">		// Only check reconcile when it is not an update, because if the pod is going to</div><div class="line">		// be updated, an extra reconcile is unnecessary</div><div class="line">		if !reflect.DeepEqual(existing.Status, ref.Status) &#123;</div><div class="line">			// Pod with changed pod status needs reconcile, because kubelet should</div><div class="line">			// be the source of truth of pod status.</div><div class="line">			existing.Status = ref.Status</div><div class="line">			needReconcile = true</div><div class="line">		&#125;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	...</div><div class="line">	</div><div class="line">	if ref.DeletionTimestamp != nil &#123;</div><div class="line">		needGracefulDelete = true</div><div class="line">	&#125; else &#123;</div><div class="line">		// 3. this is an update</div><div class="line">		needUpdate = true</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的函数体也可以看出来，kubelet 是如何定义这个 pod 是需要 update 的还是 reconcile 的，还是需要 delete 的。</p>
<p>最终 PodConfig 会把来自 3 个来源的信息经过过滤后都统一发送到一个 channel 里，也就是 kubelet 对象 watch 的 channel。</p>
<h2 id="PLEG"><a href="#PLEG" class="headerlink" title="PLEG"></a>PLEG</h2><p>在一开始的时候，我们也介绍过，PodConfig 关注的是 Pod 的静态信息的变化，而 PLEG 模块则关注的是有关 Pod 动态信息的变化了，主要指的就是 Container 的状态。</p>
<p>所以 PLEG 子模块工作逻辑也比较简单，就是一个周期性执行的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/pleg/generic.go#L182" target="_blank" rel="external">relist</a> 函数，该函数的操作主要包括</p>
<ul>
<li>访问 container runtime 获取当前所有 Pod 的 Container 的最新状态信息</li>
<li>根据缓存中记录的上一次 PLEG 获取的 Container 信息，进行比较，如果有变化则生成一个 PodLifecycleEvent 信息</li>
<li>根据整理出来的所有有 PodLifecycleEvent 事件发生的 Pod，依次再从 container runtime 或者这个 pod 最新状态细节，更新到本地缓存中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">func (g *GenericPLEG) relist() &#123;</div><div class="line">	...</div><div class="line">	// 访问 container runtime 获取当前所有 Pod 的 Container 的最新状态信息</div><div class="line">	podList, err := g.runtime.GetPods(true)</div><div class="line">	...</div><div class="line">	</div><div class="line">	// 根据缓存中记录的上一次 PLEG 获取的 Container 信息，进行比较，如果有变化则生成一个 PodLifecycleEvent 信息</div><div class="line">	eventsByPodID := map[types.UID][]*PodLifecycleEvent&#123;&#125;</div><div class="line">	for pid := range g.podRecords &#123;</div><div class="line">		oldPod := g.podRecords.getOld(pid)</div><div class="line">		pod := g.podRecords.getCurrent(pid)</div><div class="line">		// Get all containers in the old and the new pod.</div><div class="line">		allContainers := getContainersFromPods(oldPod, pod)</div><div class="line">		for _, container := range allContainers &#123;</div><div class="line">			events := computeEvents(oldPod, pod, &amp;container.ID)</div><div class="line">			for _, e := range events &#123;</div><div class="line">				updateEvents(eventsByPodID, e)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	...</div><div class="line">	</div><div class="line">	// 根据整理出来的所有有 PodLifecycleEvent 事件发生的 Pod，依次再从 container runtime 或者这个 pod 最新状态细节，更新到本地缓存中</div><div class="line">	for pid, events := range eventsByPodID &#123;</div><div class="line">		pod := g.podRecords.getCurrent(pid)</div><div class="line">		if g.cacheEnabled() &#123;</div><div class="line">			...</div><div class="line">			if err := g.updateCache(pod, pid); err != nil &#123;</div><div class="line">				glog.Errorf(&quot;PLEG: Ignoring events for pod %s/%s: %v&quot;, pod.Name, pod.Namespace, err)</div><div class="line"></div><div class="line">				// make sure we try to reinspect the pod during the next relisting</div><div class="line">				needsReinspection[pid] = pod</div><div class="line"></div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以这个消息源产生的消息类型为 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/pleg/pleg.go#L37:6" target="_blank" rel="external">PodLifecycleEvent</a>，其中就包括了这个 Pod UID，以及发生的时间的类型，以及一些相关重要数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type PodLifecycleEvent struct &#123;</div><div class="line">	// The pod ID.</div><div class="line">	ID types.UID</div><div class="line">	// The type of the event.</div><div class="line">	Type PodLifeCycleEventType</div><div class="line">	// The accompanied data which varies based on the event type.</div><div class="line">	//   - ContainerStarted/ContainerStopped: the container name (string).</div><div class="line">	//   - All other event types: unused.</div><div class="line">	Data interface&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之所以 k8s 引入 PLEG 这种方案，就是为了能够尽可能减少 kubelet 对 container runtime 的 api 频繁调用，导致 CPU 利用率升高，kubelet 可扩展性降低。更多的具体细节可以参考 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md" target="_blank" rel="external">[1]</a></p>
<h2 id="LivenessManager"><a href="#LivenessManager" class="headerlink" title="LivenessManager"></a>LivenessManager</h2><p>livenessManager 是实现针对 container 进行 liveness probe 的子模块。Pod 中的每一个 container 都可以配置 Liveness Probe 特性，其中可以指定 3 种不同的 Probe 行为</p>
<ul>
<li>http</li>
<li>tcp</li>
<li>exec </li>
</ul>
<p>具体的使用方式可以参考[<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="external">2</a>]</p>
<p>而真实对 container 进行 liveness probe 的模块就是 kubelet 对象中的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1002" target="_blank" rel="external">livenessManager</a> 以及 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1000" target="_blank" rel="external">probeManager</a></p>
<p>其中 probeManager 对象会针对每一个配置了 liveness probe 或者 readiness probe 的 pod 分配一个 worker 对象，并且保存在一个 map 中，每个 worker 会启动一个 goroutine 对 container 进行指定的 probe 操作。</p>
<p>如下就是 probeManager 对象的类型 manager 的声明，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type manager struct &#123;</div><div class="line">	// Map of active workers for probes</div><div class="line">	workers map[probeKey]*worker</div><div class="line">	...</div><div class="line"></div><div class="line">	// livenessManager manages the results of liveness probes</div><div class="line">	livenessManager results.Manager</div><div class="line"></div><div class="line">	// prober executes the probe actions.</div><div class="line">	prober *prober</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中比较重要的就是 map workers ，里面针对每一个需要 liveness probe 或者 readiness probe 的 container 都保存了一个 worker 对象。而这个 worker 对象会最终启动一个周期性的 probe goroutine，执行 liveness probe 的行为，并且把结果传输给 livenessManager 对象中。</p>
<p>而 livenessManager 对象所属的类型 result.Manager 其实也就是一个 channel，当 worker 进行 probe 的 goroutine 发现 liveness probe 有问题时，就会把这个消息传递给这个 channel，从而 kubelet 就可以 watch 到这个事件，从而进行异常处理。比如重启这个容器。</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md" target="_blank" rel="external">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md</a></li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="external">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://fatsheep9146.github.io/2018/07/22/kubelet创建Pod流程解析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ziqi Zhao (fatsheep9146)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一只肥羊的思考">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一只肥羊的思考" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/22/kubelet创建Pod流程解析/" itemprop="url">
                  kubelet创建Pod流程解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-22T15:07:07+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这篇文章主要是针对 kubelet 对 pod 的生命周期管理逻辑中，有关 pod 的创建的过程的解析。</p>
<p>就像我们在之前的文章中解释的那样，kubelet 整体是工作在生产者，消费者模型中的，所以当 一个 pod 创建的事件进入队列后，kubelet 就会及时收到这个事件，然后调用一系列相关的子模块，完成 pod 的创建工作。</p>
<h1 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h1><p>kubelet 针对 Pod 创建实现了一个 Handler 函数，<a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1990" target="_blank" rel="external">HandlePodAdditions</a>，该函数中包含pod 在创建的过程中的所有操作。我们就依次来看一下所有设计到的操作：</p>
<h3 id="Step-1-添加新创建的-Pod-到-podManager-子模块中"><a href="#Step-1-添加新创建的-Pod-到-podManager-子模块中" class="headerlink" title="Step 1: 添加新创建的 Pod 到 podManager 子模块中"></a>Step 1: 添加新创建的 Pod 到 podManager 子模块中</h3><p><a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L954" target="_blank" rel="external">podManager</a> 子模块负责管理这台机器上的 pod 的信息，pod 和 mirrorPod 之间的对应关系等等。</p>
<p>在创建 pod 时第一步操作就是把这个 Pod 的信息存入 podManager 中，供后续子模块查询使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func (kl *Kubelet) HandlePodAdditions(pods []*v1.Pod) &#123;</div><div class="line">		....</div><div class="line">		kl.podManager.AddPod(pod)</div><div class="line">		....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1999:17" target="_blank" rel="external">代码链接</a></p>
<h3 id="Step-2-将创建-Pod-的工作下发给-podWorkers-子模块"><a href="#Step-2-将创建-Pod-的工作下发给-podWorkers-子模块" class="headerlink" title="Step 2: 将创建 Pod 的工作下发给 podWorkers 子模块"></a>Step 2: 将创建 Pod 的工作下发给 podWorkers 子模块</h3><p><a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L943" target="_blank" rel="external">podWorkers</a> 子模块 主要负责为每一个 Pod 启动，并且创建单独的 goroutine 去真实的对这个 Pod 完成相应的操作，比如创建，更新，删除等等。</p>
<p>而 HandlePodAdditions 中的对 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L2021" target="_blank" rel="external">dispatchWork</a> 函数的调用就会真实的把某个对 Pod 的操作（创建/更新/删除）下发给 podWorkers，在这里我们关注的是 Pod 的创建动作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func (kl *Kubelet) HandlePodAdditions(pods []*v1.Pod) &#123;</div><div class="line">   ...</div><div class="line">   	kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</div><div class="line">   	...</div><div class="line">&#125;	</div><div class="line"></div><div class="line">func (kl *Kubelet) dispatchWork(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time) &#123;</div><div class="line">	...</div><div class="line">		kl.podWorkers.UpdatePod(&amp;UpdatePodOptions&#123;</div><div class="line">		Pod:        pod,</div><div class="line">		MirrorPod:  mirrorPod,</div><div class="line">		UpdateType: syncType,</div><div class="line">		OnCompleteFunc: func(err error) &#123;</div><div class="line">			if err != nil &#123;</div><div class="line">				metrics.PodWorkerLatency.WithLabelValues(syncType.String()).Observe(metrics.SinceInMicroseconds(start))</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">	&#125;)</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Step-3-podWorkers-子模块为该-Pod-启动一个处理对-Pod-的更新事件的-goroutine"><a href="#Step-3-podWorkers-子模块为该-Pod-启动一个处理对-Pod-的更新事件的-goroutine" class="headerlink" title="Step 3: podWorkers 子模块为该 Pod 启动一个处理对 Pod 的更新事件的 goroutine"></a>Step 3: podWorkers 子模块为该 Pod 启动一个处理对 Pod 的更新事件的 goroutine</h3><p>podWorkers 子模块主要的作用就是处理针对每一个的 Pod 的更新事件，比如 Pod 的创建，删除，更新。而 podWorkers 采取的基本思路是：为每一个 Pod 都单独创建一个 goroutine 和 更新事件的 channel，goroutine 会阻塞式的等待 channel 中的事件，并且对获取的事件进行处理。而 podWorkers 对象自身则主要负责对更新事件进行下发。</p>
<p>所以 podWorker 创建针对每一个的 Pod 的【处理 goroutine】 还有【下发事件给处理 goroutine】的动作都是在 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/pod_workers.go#L195" target="_blank" rel="external">UpdatePod</a> 函数中完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func (p *podWorkers) UpdatePod(options *UpdatePodOptions) &#123;</div><div class="line">	...</div><div class="line">	if podUpdates, exists = p.podUpdates[uid]; !exists &#123; // 如果当前 pod 还没有启动过 goroutine ，则启动 goroutine，并且创建 channel</div><div class="line">	</div><div class="line">		// 创建 channel</div><div class="line">		podUpdates = make(chan UpdatePodOptions, 1)</div><div class="line">		p.podUpdates[uid] = podUpdates</div><div class="line"></div><div class="line">		// 启动 goroutine</div><div class="line">		go func() &#123; </div><div class="line">			defer runtime.HandleCrash()</div><div class="line">			p.managePodLoop(podUpdates)</div><div class="line">		&#125;()</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	if !p.isWorking[pod.UID] &#123; // 下发更新事件</div><div class="line">		p.isWorking[pod.UID] = true</div><div class="line">		podUpdates &lt;- *options </div><div class="line">	&#125; else &#123;</div><div class="line">		....</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="Step-4-处理-pod-更新事件的-goroutine-开始操作"><a href="#Step-4-处理-pod-更新事件的-goroutine-开始操作" class="headerlink" title="Step 4: 处理 pod 更新事件的 goroutine 开始操作"></a>Step 4: 处理 pod 更新事件的 goroutine 开始操作</h3><p>podWorkers 为每一个 pod 启动一个处理事件的 goroutine，goroutine 主要调用的是 managePodLoop 函数，这个函数内部将会利用 range 阻塞式的等待更新事件的到来，直到 channel 被关闭。</p>
<p>针对每一个事件 goroutine 会调用 kubelet 对象的 syncPodFn 函数真实的完成这次更新行为。</p>
<p>在完成这次 sync 动作之后，会调用 wrapUp 函数，这个函数将会做几件事情</p>
<ul>
<li>将这个 pod 信息插入 kubelet 的 workQueue 队列中，等待下一次周期性的对这个 pod 的状态进行 sync </li>
<li>将在这次 sync 期间堆积的没有能够来得及处理的最近一次 update 操作加入 goroutine 的事件 channel 中，立即处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (p *podWorkers) managePodLoop(podUpdates &lt;-chan UpdatePodOptions) &#123;</div><div class="line">	...</div><div class="line">	for update := range podUpdates &#123;</div><div class="line">	...</div><div class="line">		err = p.syncPodFn(syncPodOptions&#123;</div><div class="line">			mirrorPod:      update.MirrorPod,</div><div class="line">			pod:            update.Pod,</div><div class="line">			podStatus:      status,</div><div class="line">			killPodOptions: update.KillPodOptions,</div><div class="line">			updateType:     update.UpdateType,</div><div class="line">		&#125;）</div><div class="line">	...</div><div class="line">		p.wrapUp(update.Pod.UID, err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 managePodLoop 中调用的 syncPodFn 的实现其实是 kubelet 对象的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1441" target="_blank" rel="external">syncPod</a> 方法</p>
<p>在这个方法中，主要完成几件事情</p>
<ul>
<li>首先根据从 container runtime 那边获取的当前 pod 所有容器的状态，以及 pod 的描述信息得出 pod 整体的状态，并且发送给 kubelet.statusManager。而 statusManager 的工作就是周期性的把 podStatus 同步到 apiserver 去。</li>
<li>然后调用 kubelet.containerManager 的 NewPodContainerManager 方法，为这个 pod 创建一个 cgroup 的 manager，这个 manager 对象专门用户为这个 pod 创建，并且管理 pod 级别的 cgroup。所以紧接着，针对 pod 的创建事件，这个 pod 的 cgroup manager 主要做两件事情<ul>
<li>创建 pod level cgroup</li>
<li>更新这台机器的 qos level cgroup</li>
</ul>
</li>
<li>然后为这个 pod 创建一系列必要的本地目录，主要用于存放 kubelet 的元数据，pod 内容器的挂载点等等。</li>
<li>然后调用 kubelet.volumeManager 组件，等待它将 pod 所需要的所有外挂的 volume 都准备好。</li>
<li>最终调用 kubelet.containerRuntime 组件，创建这个 pod 实体。containerRuntime 组件也是 kubelet 中用于负责同 container runtime 进行交互的组件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func (kl *Kubelet) syncPod(o syncPodOptions) error &#123;</div><div class="line">	...</div><div class="line">	// 1. 同步 podStatus 到 kubelet.statusManager</div><div class="line">	apiPodStatus := kl.generateAPIPodStatus(pod, podStatus)</div><div class="line">	...</div><div class="line">	kl.statusManager.SetPodStatus(pod, apiPodStatus)</div><div class="line">	...</div><div class="line">	</div><div class="line">	// 2. 创建 containerManagar 对象，并且创建 pod level cgroup，更新 Qos level cgroup</div><div class="line">	pcm := kl.containerManager.NewPodContainerManager()</div><div class="line">	...</div><div class="line">				if err := kl.containerManager.UpdateQOSCgroups(); err != nil &#123;</div><div class="line">	...</div><div class="line">				if err := pcm.EnsureExists(pod); err != nil &#123;</div><div class="line">	...</div><div class="line">	</div><div class="line">	// 3. 为 pod 创建数据目录</div><div class="line">	if err := kl.makePodDataDirs(pod); err != nil &#123;</div><div class="line">	...</div><div class="line">	</div><div class="line">	// 4. 等待 kubelet.volumeManager 为 pod 完成必要的 volume 准备</div><div class="line">		if err := kl.volumeManager.WaitForAttachAndMount(pod); err != nil &#123;</div><div class="line">		</div><div class="line">	// 5. 最终调用 kubelet.containerRuntime 的 SyncPod 方法，完成 pod 实体的创建</div><div class="line">	result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff)</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Step-5-创建-Pod-实体"><a href="#Step-5-创建-Pod-实体" class="headerlink" title="Step 5: 创建 Pod 实体"></a>Step 5: 创建 Pod 实体</h3><p>在上面一个步骤中，我们看到主要完成的都是创建 Pod 实体（即容器）之前需要完成的准备工作。在准备工作完成之后，最终调用 kubelet.containerRuntime 子模块的 SyncPod 函数真正完成 Pod 内容器实体的创建。</p>
<p>这个 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L568" target="_blank" rel="external">SyncPod</a> 方法的实现位于 kuberuntime 包中，其中主要完成几个步骤</p>
<ul>
<li>创建 PodSandbox 容器</li>
<li>如果 Pod 中指定了 initContainers 的话，则创建 InitContainer 容器</li>
<li>创建用户业务 Container</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;</div><div class="line">	...</div><div class="line">	// 1. 创建 PodSandbox 容器</div><div class="line">	podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt)</div><div class="line">	...</div><div class="line">	</div><div class="line">	// 2. 启动 initContainer 容器</div><div class="line">	if msg, err := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP); err != nil &#123;</div><div class="line"></div><div class="line">	...		</div><div class="line">	// 3. 启动业务容器</div><div class="line">	for _, idx := range podContainerChanges.ContainersToStart &#123;</div><div class="line">	...</div><div class="line">	if msg, err := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP); err != nil &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当所有一切动作都完成之后，一个完整的 Pod 就已经创建起来了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://fatsheep9146.github.io/2018/07/08/kubelet内部实现解析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ziqi Zhao (fatsheep9146)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一只肥羊的思考">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一只肥羊的思考" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/08/kubelet内部实现解析/" itemprop="url">
                  kubelet内部实现解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T20:09:49+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>kubelet 组件作为每台 kubernetes 集群中每台计算节点上运行的 agent，主要职责有两个</p>
<ul>
<li>管理这台机器上面的 pod 的生命周期，</li>
<li>自动上报，并且维护这台计算节点的状态</li>
</ul>
<p>这篇文章的目的就在于对 kubelet 整体的设计框架进行分析。并不会对任意一个子功能的细节进行深入的介绍。后续会有一系列文章对 kubelet 组件的各种功能进行详细的介绍。</p>
<h1 id="kubelet-内部结构"><a href="#kubelet-内部结构" class="headerlink" title="kubelet 内部结构"></a>kubelet 内部结构</h1><p>kubelet 内部其实是由多个【子模块】来构成的，每个子模块都单独负责一部分的任务，而在代码中，所有的子模块对象都包含在下面两个对象中，这两个对象也是 kubelet 中最重要的两个对象</p>
<ul>
<li><p>kubeDeps：该对象（类型为 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L229" target="_blank" rel="external">Dependencies</a>）主要包含一些 kubelet 依赖的外部功能，比如 cadvisor（监控功能），containerManager（cgroup 管理功能）。</p>
</li>
<li><p>kubelet：kubelet 对象（类型为 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L931" target="_blank" rel="external">Kubelet</a>）则代表 kubelet 内部跟 pod 息息相关的子模块，比如 podManager（pod 信息存储模块），probeManager（pod 测活模块）等等。</p>
</li>
</ul>
<p>那么 kubelet 中各个子模块之间又是如何配合工作的呢？主要是基于生产者消费者的模型。</p>
<p>整个 kubelet 的工作模式就是在围绕着不同的生产者生产出来的不同的有关 pod 的消息来调用相应的消费者（不同的子模块）完成不同的行为，比如创建 pod，删除 pod，如下图所示</p>
<p><img src="kubelet_structure_0.png" alt=""></p>
<p>那么 kubelet 中主要包含哪几个消息的生产者呢？消费者又是怎么消费的呢？</p>
<p>我们可以在 kubelet 的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1839" target="_blank" rel="external">syncLoopIteration</a> 函数中看到 kubelet 到底同时接收哪几个信息源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// * configCh: dispatch the pods for the config change to the appropriate</div><div class="line">//             handler callback for the event type</div><div class="line">// * plegCh: update the runtime cache; sync pod</div><div class="line">// * syncCh: sync all pods waiting for sync</div><div class="line">// * houseKeepingCh: trigger cleanup of pods</div><div class="line">// * liveness manager: sync pods that have failed or in which one or more</div><div class="line">//                     containers have failed liveness checks</div><div class="line">func (kl *Kubelet) syncLoopIteration(...) &#123;</div><div class="line">	case u, open := &lt;-configCh:</div><div class="line">		...</div><div class="line">	case e := &lt;-plegCh:</div><div class="line">		...</div><div class="line">	case &lt;-syncCh:</div><div class="line">		...</div><div class="line">	case update := &lt;-kl.livenessManager.Updates():</div><div class="line">		...</div><div class="line">	case &lt;-housekeepingCh:</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过代码注释可以看出，kubelet 主要有 5 个不同的信息源</p>
<ul>
<li>configCh: 该信息源由 kubeDeps 对象中的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L266:34" target="_blank" rel="external">PodConfig</a> 子模块提供，该模块将同时 watch 3 个不同来源的 pod 信息的变化（file，http，apiserver），一旦某个来源的 pod 信息发生了更新（创建/更新/删除），这个 channel 中就会出现被更新的 pod 信息和更新的具体操作。</li>
<li>plegCh: 该信息源由 kubelet 对象中的 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1081" target="_blank" rel="external">pleg</a> 子模块提供，该模块主要用于周期性地向 container runtime 查询当前所有容器的状态，如果状态发生变化，则这个 channel 产生事件。[1]</li>
<li>syncCh: 该信息源是一个周期性的信号源(默认1秒)，周期性同步所有需要再次同步的 pod。</li>
<li>liveness manager update: 该信息源是由 kubelet 对象中 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L1002" target="_blank" rel="external">livenessManager</a>管理，当某个容器的 liveness probe 状态发生了变化，则会产生事件。</li>
<li>housekeepingCh: 该信息源也是一个周期性信号源(默认2秒)，周期性的清理一些无用 pod。</li>
</ul>
<p>所有的这些消息源产生的消息都由 kubelet 对象统一接受，并且调用相应的功能函数来完成相应的操作。</p>
<p>kubelet 对象自身实现一系列处理不同事件的 handler 函数，并且汇总成 <a href="https://github.com/kubernetes/kubernetes/blob/dd5e1a2978fd0b97d9b78e1564398aeea7e7fe92/pkg/kubelet/kubelet.go#L170" target="_blank" rel="external">SyncHandler</a> 接口，其中包含针对不同信息源里不同消息类型的处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type SyncHandler interface &#123;</div><div class="line">	HandlePodAdditions(pods []*v1.Pod)</div><div class="line">	HandlePodUpdates(pods []*v1.Pod)</div><div class="line">	HandlePodRemoves(pods []*v1.Pod)</div><div class="line">	HandlePodReconcile(pods []*v1.Pod)</div><div class="line">	HandlePodSyncs(pods []*v1.Pod)</div><div class="line">	HandlePodCleanups() error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，每一个处理函数背后可能都需要 kubelet 对象去调用背后多个内部子模块来共同完成，比如 HandlePodAddition 函数，处理 Pod 的创建，其中可能需要</p>
<ul>
<li>调用 kubelet.podManager 子模块 AddPod 函数，注册该 pod 信息</li>
<li>调用 kubelet.podWorker 子模块为这个 Pod 创建单独的 worker goroutine 完成具体的操作</li>
<li>调用 kubelet.containerManager 子模块为这个 Pod 创建相应的 Pod Level Cgroup </li>
<li>调用 kubelet.volumeManager 子模块为这个 Pod 准备需要被 Mount 到容器中的文件系统</li>
<li>调用 kubelet.containerRuntime 子模块真正的创建 Pod 的实体</li>
<li>….</li>
</ul>
<p>所以综上，整个 kubelet 的所有内部子模块就是通过这种生产者消费者模型协调工作，及时将 Pod 以用户期望的状态维护在它所在的机器上。</p>
<p>上面说到的只是 kubelet 中和 pod 管理相关的结构，kubelet 中还包括一些为了</p>
<ul>
<li>维护物理机稳定性</li>
<li>同步更新物理机配置</li>
</ul>
<p>等目的，周期性不间断工作的子模块，他们也是 kubelet 中非常重要的一部分。</p>
<p>所以这篇文章作为一个综述，是一系列文章的开端，我将通过一系列博文来解析 kubelet 的内部结构的细节，针对 kubelet 每一个比较重要的子模块，子功能进行单独的介绍。</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md" target="_blank" rel="external">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Ziqi Zhao (fatsheep9146)" />
          <p class="site-author-name" itemprop="name">Ziqi Zhao (fatsheep9146)</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ziqi Zhao (fatsheep9146)</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


</body>
</html>
